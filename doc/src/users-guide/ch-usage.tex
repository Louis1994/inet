\chapter{Using the INET Framework}
\label{cha:usage}

\section{Installation}

There are several ways to install the INET Framework:

\begin{itemize}
  \item Let the OMNeT++ IDE download and install it for you. 
      This is the easiest way. Just accept the offer to install INET
      in the dialog that comes up when you first start the IDE, or
      choose \textit{Help > Install Simulation Models} any time later.
  \item From INET Framework web site, \textit{http://inet.omnetpp.org}. 
      The IDE always installs the last stable version compatible with
      your version of OMNeT++. If you need some other version, they
      are available for download from the web site. Installation
      instructions are also provided there.  
  \item From GitHub. If you have experience with \textit{git}, 
      clone the INET Framework project (\ttt{inet\--frame\-work/inet}), 
      check out the revision of your choice, and follow the INSTALL 
      file in the project root.
\end{itemize}
 
 
\section{Installing INET Extensions}

If you plan to make use of INET extensions (e.g. Veins or SimuLTE),
follow the installation instructions provided with them. 

In the absence of specific instructions, the following procedure usually works: 

\begin{itemize}
 \item First, check if the project root contains a file named \ttt{.project}.
 \item If it does, then the project can be imported into the IDE (use \textit{File > Import >
    General > Existing Project} into workspace). make sure that the project is recognized
    as an OMNeT++ project (the \textit{Project Properties} dialog contains a page
    titled \textit{OMNeT++}), and it lists the INET project as dependency 
    (check the \textit{Project References} page in the \textit{Project Properties} dialog).
 \item If there is no \ttt{.project} file, you can create an empty OMNeT++
    project using the \textit{New OMNeT++ Project} wizard in \textit{File > New}, 
    add the INET project as dependency using the \textit{Project References} page 
    in the \textit{Project Properties} dialog, and copy the source files into the project.
\end{itemize}

\section{INET as an OMNeT++-based simulation framework}

The INET Framework builds upon OMNeT++, and uses the same concept: modules
that communicate by message passing. Hosts, routers, switches and other
network devices are represented by OMNeT++ compound modules. These compound
modules are assembled from simple modules that represent protocols,
applications, and other functional units. A network is again an OMNeT++
compound module that contains host, router and other modules. The external
interfaces of modules are described in NED files. NED files describe the
parameters and gates (i.e. ports or connectors) of modules, and also the
submodules and connections (i.e. netlist) of compound modules.

Modules are organized into hierarchical \textit{packages} that directly map to
a folder tree, very much like Java packages. Packages in
INET are organized roughly according to OSI layers; the top packages
include \ttt{inet.applications}, \ttt{inet.transportlayer},
\ttt{inet.networklayer}, \ttt{inet.linklayer}, and \ttt{inet.physicallayer}. 
Other packages are \ttt{inet.routing}, \ttt{inet.mobility}, \ttt{inet.power}, 
\ttt{inet.environment}, and \ttt{inet.node}. These packages correspond to the
\ttt{src/applications/}, \ttt{src/transportlayer/}, etc. directories in the
INET source tree. (The \ttt{src/inet/} directory corresponds to the \ttt{inet} 
package, as defined by the \ttt{src/inet/package.ned} file.) Subdirectories
within the top packages usually correspond to concrete protocols or protocol
families. The implementations of simple modules are C++ classes with the same
name, with the source files placed in the same directory as the NED file.

The \ttt{inet.node} package contains various pre-assembled host, router,
switch, access point, and other modules, for example
\nedtype{StandardHost}, \nedtype{Router} and \nedtype{EtherSwitch} and
\nedtype{AccessPoint}. These compound modules contain some customization
options via parametric submodule types, but they are not meant to be
universal, so it may be necessary to create your own node models for
your particular simulation scenarios.

Network interfaces (Ethernet, IEEE 802.11, etc) are usually compound modules
themselves, and are being composed of a queue, a MAC, and possibly other
simple modules. See \nedtype{EthernetInterface} as an example.

Not all modules implement protocols. There are modules which hold data (for
example \nedtype{Ipv4RoutingTable}), perform autoconfiguration of a network
(\nedtype{Ipv4NetworkConfigurator}), move a mobile node around (for example
\nedtype{ConstSpeedMobility}), and perform housekeeping associated with
radio signals in wireless simulations (\nedtype{RadioMedium}).

Protocol headers and packet formats are described in message definition
files (msg files), which are translated into C++ classes by OMNeT++'s
\textit{opp\_msgc} tool. The generated message classes subclass from OMNeT++'s
\ttt{cPacket} or \ttt{cMessage} classes.

The internal structure of compound modules such as host and router models
can be customized in several ways. The first way is the use of \textit{gate
vectors} and \textit{submodule vectors}. The sizes of vectors may come from
parameters or derived by the number of external connections to the module.
For example, one can have an Ethernet switch model that has as many ports
as needed, i.e. equal to the number of Ethernet devices connected to it.

The second way of customization is \textit{parametric types}, that is, the
type of a submodule (or a channel) may be specified as a string parameter.
For example, the relay unit inside an Ethernet switch has several
alternative implementations, each one being a distinct module type. The
switch model contains a parameter which allows the user to select the
appropriate relay unit implementation.

A third way of customizing modules is \textit{inheritance}: a derived
module may add new parameters, gates, submodules or connections, and may
set inherited unassigned parameters to specific values.


\section{Creating and Running Simulations}

To create a simulation, you would write a NED file that contains the network,
i.e. routers, hosts and other network devices connected together. You can
use a text editor or the IDE's graphical editor to create the network.

Modules in the network contain a lot of unassigned parameters, which need
to be assigned before the simulation can be run.\footnote{The simulator can
interactively ask for parameter values, but this is not very convenient
for repeated runs.} The name of the network to be simulated, parameter values
and other configuration option need to be specified in the \ttt{omnetpp.ini}
file.\footnote{This is the default file name; using other is also possible.}

\ttt{omnetpp.ini} contains parameter assignments as \textit{key=value}
lines, where each key is a wildcard pattern. The simulator matches these
wildcard patterns against full path of the parameter in the module tree
(something like \ttt{Test.host[2].tcp.nagleEnabled}), and value from
the first match will be assigned for the parameter. If no matching line is
found, the default value in the NED file will be used. (If there is no
default value either, the value will be interactively prompted for, or, in
case of a batch run, an error will be raised.)

There are two kinds of wildcards: a single asterisk \ttt{*} matches at most
one component name in the path string, while double asterisk \ttt{**} may
match multiple components. Technically: \ttt{*} never matches a dot or a
square bracket (\ttt{.}, \ttt{[}, \ttt{]}), while \ttt{**} can match any of
them. Patterns are also capable of expressing index ranges
(\ttt{**.host[1..3,5,8].tcp.nagleEnabled}) and ranges of numbers embedded
in names (\ttt{**.switch\{2..3\}.relayUnitType}).

OMNeT++ allows several configurations to be put into the \ttt{omnetpp.ini}
file under \ttt{[Config <name>]} section headers, and the right
configuration can be selected via command-line options when the simulation
is run. Configurations can also build on each other: \ttt{extends=<name>}
lines can be used to set up an inheritance tree among them. This feature
allows minimizing clutter in ini files by letting you factor out common
parts. (Another ways of factoring out common parts are ini file inclusion
and specifying multiple ini files to a simulation.) Settings in the
\ttt{[General]} section apply to all configurations, i.e. \ttt{[General]}
is the root of the section inheritance tree.

Parameter studies can be defined by specifying multiple values for a
parameter, with the \ttt{\$\{10,50,100..500 step 100, 1000\}} syntax;
a repeat count can also be specified.

\ifdraft TODO
how to run;

C++ -> dll (opp\_run) or exe
\fi

\section{Result Collection and Analysis}

how to analyize results

how to configure result collection


\section{Setting up wired network simulations}

For an introduction, in this section we show you how to set up simulations
of wired networks using PPP or Ethernet links with autoconfigured static IP
routing. (If your simulation involves more, such as manually configured
routing tables, dynamic routing, MPLS, or IPv6 or other features and protocols,
you'll find info about them in later chapters.)

Such a network can be assembled using the predefined \nedtype{StandardHost}
and \nedtype{Router} modules. For automatic IP address assignment and
static IP routing we can use the \nedtype{Ipv4NetworkConfigurator} utility
module.

TODO:  ethg, pppg;  automatically expand (++)

todo which modules are needed into it, what they do, etc.

how to add apps, etc


\section{Setting up wireless network simulations}

In this section we show you how to set up wireless network simulations using
IEEE 802.11 links with autoconfigured static IP routing. Such a network can be
assembled using the predefined \nedtype{WirelessHost} and \nedtype{AccessPoint}
modules. \nedtype{RadioMedium} is also required for wireless simulations. It
keeps track of which nodes are within interference distance of other nodes.

TODO

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:

